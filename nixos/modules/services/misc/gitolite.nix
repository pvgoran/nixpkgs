{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.services.gitolite;
  # Use writeTextDir to not leak Nix store hash into file name
  pubkeyFile = (pkgs.writeTextDir "gitolite-admin.pub" cfg.adminPubkey) + "/gitolite-admin.pub";
  hooks = lib.concatMapStrings (hook: "${hook} ") cfg.commonHooks;
in
{
  options = {
    services.gitolite = {
      enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          Enable gitolite management under the
          <literal>gitolite</literal> user. After
          switching to a configuration with Gitolite enabled, you can
          then run <literal>git clone
          gitolite@host:gitolite-admin.git</literal> to manage it further.
        '';
      };

      dataDir = mkOption {
        type = types.str;
        default = "/var/lib/gitolite";
        description = ''
          Gitolite home directory (used to store all the repositories).
        '';
      };

      adminPubkey = mkOption {
        type = types.str;
        description = ''
          Initial administrative public key for Gitolite. This should
          be an SSH Public Key. Note that this key will only be used
          once, upon the first initialization of the Gitolite user.
          The key string cannot have any line breaks in it.
        '';
      };

      commonHooks = mkOption {
        type = types.listOf types.path;
        default = [];
        description = ''
          A list of custom git hooks that get copied to <literal>~/.gitolite/hooks/common</literal>.
        '';
      };

      manageGitoliteRc = mkOption {
        type = types.bool;
        default = true;
        description = ''
          Make the <literal>~/.gitolite.rc</literal> configuration file managed by NixOS.

          If this option is set (which is the default), the
          <literal>~/.gitolite.rc</literal> file becomes a symlink to a file
          in Nix store. Customizations to it should be done with the
          <literal>extraGitoliteRc</literal> option.

          If you already have a customized (or otherwise changed)
          <literal>~/.gitolite.rc</literal> file, you need to take any customizations
          you may have, convert them to appropriate Perl statements for
          <literal>extraGitoliteRc</literal>, and remove the
          <literal>~/.gitolite.rc</literal> file. Until this is done, NixOS will
          complain to system log about the file being customized, and will refuse
          to replace it with a symlink. Alternatively, you can just disable
          the <literal>manageGitoliteRc</literal> option.
        '';
      };

      extraGitoliteRc = mkOption {
        type = types.lines;
        default = "";
        example = literalExample ''
          $RC{UMASK} = 0027;
          $RC{SITE_INFO} = 'This is our private repository host';
          push( @{$RC{ENABLE}}, 'Kindergarten' ); # enable the command/feature
          @{$RC{ENABLE}} = grep { $_ ne 'desc' } @{$RC{ENABLE}}; # disable the command/feature
        '';
        description = ''
          Extra configuration to append to <literal>~/.gitolite.rc</literal>.
          Requires <literal>manageGitoliteRc</literal> to be enabled.

          This should be Perl code that modifies the <literal>%RC</literal>
          configuration variable. The default <literal>~/.gitolite.rc</literal>
          content is generated by invoking <literal>gitolite print-default-rc</literal>,
          and extra configuration from this option is appended to it.
        '';
      };

      user = mkOption {
        type = types.str;
        default = "gitolite";
        description = ''
          Gitolite user account. This is the username of the gitolite endpoint.
        '';
      };
    };
  };

  config = mkIf cfg.enable (
  let
    rcDir = pkgs.runCommand "gitolite-rc" { } rcDirScript;
    rcDirScript =
      ''
        mkdir "$out"
        export HOME=temp-home
        mkdir -p "$HOME/.gitolite/logs" # gitolite can't run without it
        '${pkgs.gitolite}'/bin/gitolite print-default-rc >>"$out/gitolite.rc.default"
        cat <<END >>"$out/gitolite.rc"
        # This file is managed by NixOS.
        # Use services.gitolite options to control it.

        END
        cat "$out/gitolite.rc.default" >>"$out/gitolite.rc"
      '' +
      optionalString (cfg.extraGitoliteRc != "") ''
        echo -n ${escapeShellArg ''

          # Added by NixOS:
          ${removeSuffix "\n" cfg.extraGitoliteRc}

          # per perl rules, this should be the last line in such a file:
          1;
        ''} >>"$out/gitolite.rc"
      '';
  in {
    assertions = [
      { assertion = cfg.extraGitoliteRc != "" -> cfg.manageGitoliteRc;
        message = ''
          Using services.gitolite.extraGitoliteRc requires
          services.gitolite.manageGitoliteRc to be enabled.
        '';
      }
    ];

    users.extraUsers.${cfg.user} = {
      description     = "Gitolite user";
      home            = cfg.dataDir;
      createHome      = true;
      uid             = config.ids.uids.gitolite;
      useDefaultShell = true;
    };

    systemd.services."gitolite-init" = {
      description = "Gitolite initialization";
      wantedBy    = [ "multi-user.target" ];
      unitConfig.RequiresMountsFor = cfg.dataDir;

      serviceConfig.User = "${cfg.user}";
      serviceConfig.Type = "oneshot";
      serviceConfig.RemainAfterExit = true;

      path = [ pkgs.gitolite pkgs.git pkgs.perl pkgs.bash pkgs.diffutils config.programs.ssh.package ];
      script =
      let
        rcSetupScriptIfCustomFile =
          if cfg.manageGitoliteRc then ''
            cat <<END
            <3>WARNING: Since NixOS 17.09, .gitolite.rc is managed
            <3>declaratively by default. You seem to have a manually
            <3>customized .gitolite.rc file, so it won't be replaced
            <3>with a NixOS-managed symlink to preserve your changes.
            <3>See the services.gitolite.manageGitoliteRc option
            <3>in "man configuration.nix" for more information.
            END
          '' else ''
            :
          '';
        rcSetupScriptIfDefaultFileOrStoreSymlink =
          if cfg.manageGitoliteRc then ''
            ln -sf "${rcDir}/gitolite.rc" "$GITOLITE_RC"
          '' else ''
            rm -f "$GITOLITE_RC"
          '';
      in
        ''
          cd ${cfg.dataDir}
          mkdir -p .gitolite/logs

          GITOLITE_RC=.gitolite.rc
          GITOLITE_RC_DEFAULT=${rcDir}/gitolite.rc.default
          if ( [[ ! -e "$GITOLITE_RC" ]] && [[ ! -L "$GITOLITE_RC" ]] ) ||
             ( [[ -f "$GITOLITE_RC" ]] && diff -q "$GITOLITE_RC" "$GITOLITE_RC_DEFAULT" >/dev/null ) ||
             ( [[ -L "$GITOLITE_RC" ]] && [[ "$(readlink "$GITOLITE_RC")" =~ ^/nix/store/ ]] )
          then
        '' + rcSetupScriptIfDefaultFileOrStoreSymlink +
        ''
          else
        '' + rcSetupScriptIfCustomFile +
        ''
          fi

          if [ ! -d repositories ]; then
            gitolite setup -pk ${pubkeyFile}
          fi
          if [ -n "${hooks}" ]; then
            cp ${hooks} .gitolite/hooks/common/
            chmod +x .gitolite/hooks/common/*
          fi
          gitolite setup # Upgrade if needed
        '';
    };

    environment.systemPackages = [ pkgs.gitolite pkgs.git ];
  });
}
